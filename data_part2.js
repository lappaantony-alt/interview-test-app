window.QUIZ_DATA = window.QUIZ_DATA || [];
window.QUIZ_DATA.push(...[
    {
        "id": 51,
        "topic": "Java OOP",
        "question": "Що таке наслідування?",
        "answer": "Наслідування дозволяє одному класу (підклас) отримувати властивості та методи іншого класу (суперклас), сприяючи повторному використанню коду.",
        "wrongAnswers": [
            "Принцип, що дозволяє об’єктам різних класів мати однакові імена методів з різною логікою.",
            "Процес приховування внутрішніх даних об’єкта від прямого доступу ззовні."
        ]
    },
    {
        "id": 52,
        "topic": "Java OOP",
        "question": "Що таке поліморфізм?",
        "answer": "Поліморфізм – це здатність об’єктів різних класів реагувати на один і той самий виклик методу по-різному, зазвичай реалізується через перевизначення методів.",
        "wrongAnswers": [
            "Створення багатьох екземплярів одного класу за допомогою циклу for.",
            "Можливість автоматичного перетворення рядка в число за допомогою методів Integer."
        ]
    },
    {
        "id": 53,
        "topic": "Java OOP",
        "question": "Що таке абстракція?",
        "answer": "Абстракція полягає у виділенні лише важливих характеристик об’єкта та прихованні подробиць його реалізації, реалізується через абстрактні класи та інтерфейси.",
        "wrongAnswers": [
            "Принцип, що забороняє будь-яку зміну стану об’єкта після його створення.",
            "Видалення з коду всіх коментарів для зменшення розміру вихідних файлів Java."
        ]
    },
    {
        "id": 54, "topic": "Java OOP", "question": "Що таке інтерфейс?", "answer": "Інтерфейс – це контракт, що визначає методи, які клас повинен реалізувати, не визначаючи саму логіку виконання (до Java 8).",
        "wrongAnswers": [
            "Це графічне вікно з кнопками та полями для введення тексту.",
            "Це клас, що не має жодного поля та не може мати конструктора."
        ]
    },
    {
        "id": 55, "topic": "Java OOP", "question": "Що таке абстрактний клас?", "answer": "Абстрактний клас – це клас, який не може мати екземплярів і служить основою для інших класів, може містити як абстрактні методи, так і методи з реалізацією.",
        "wrongAnswers": [
            "Клас, що складається лише із закоментованого коду та ігнорується JVM.",
            "Клас, який може мати лише приватні конструктори та не може бути успадкований."
        ]
    },
    {
        "id": 56, "topic": "Java OOP", "question": "Чим відрізняється інтерфейс від абстрактного класу?", "answer": "Клас може реалізовувати багато інтерфейсів, але успадковувати лише один абстрактний клас. Абстрактні класи можуть мати поля стану, а інтерфейси – лише константи.",
        "wrongAnswers": [
            "Інтерфейси завжди платні у використанні, а абстрактні класи безкоштовні.",
            "Абстрактні класи пишуться на Java, а інтерфейси на SQL або HTML."
        ]
    },
    {
        "id": 57, "topic": "Java OOP", "question": "Що таке перевизначення (overriding) методу?", "answer": "Перевизначення – це зміна реалізації методу суперкласу в підкласі з тією ж сигнатурою.",
        "wrongAnswers": [
            "Створення декількох методів з однаковим ім'ям у межах одного класу.",
            "Називання локальної змінної так само, як називається глобальна змінна класу."
        ]
    },
    {
        "id": 58, "topic": "Java OOP", "question": "Що таке ключове слово super?", "answer": "super використовується для звернення до методів, полів або конструкторів батьківського класу.",
        "wrongAnswers": [
            "Це префікс для методів, які працюють швидше за звичайні методи.",
            "Ключове слово для створення об’єктів, що мають доступ до прав адміністратора."
        ]
    },
    {
        "id": 59, "topic": "Java OOP", "question": "Що таке ключове слово this?", "answer": "this посилається на поточний екземпляр класу.",
        "wrongAnswers": [
            "Використовується для створення посилання на наступний елемент у списку.",
            "Це ключове слово для позначення завершення роботи всього додатка."
        ]
    },
    {
        "id": 60, "topic": "Java OOP", "question": "Що таке ключове слово final?", "answer": "final може бути застосоване до класів (забороняє наслідування), методів (забороняє перевизначення) або змінних (робить їх константами).",
        "wrongAnswers": [
            "Це ключове слово, яке обов'язково ставиться в кінці кожного файлу .java.",
            "Воно використовується для примусового виклику Garbage Collector у системі."
        ]
    },
    {
        "id": 61, "topic": "Java OOP", "question": "Які типи зв’язків між класами ви знаєте?", "answer": "Наслідування (is-a), асоціація, агрегація та композиція (has-a).",
        "wrongAnswers": [
            "Математичні, логічні, текстові та графічні типи зв'язків.",
            "Прямий, зворотний, паралельний та послідовний зв'язки."
        ]
    },
    {
        "id": 62, "topic": "Java OOP", "question": "Що таке асоціація?", "answer": "Асоціація – це зв’язок «один з одним», коли об’єкти незалежні, але знають один про одного.",
        "wrongAnswers": [
            "Це повне копіювання одного об’єкта всередину іншого для безпеки.",
            "Це механізм підключення Java-класу до певної папки на комп'ютері."
        ]
    },
    {
        "id": 63, "topic": "Java OOP", "question": "Що таке агрегація?", "answer": "Агрегація – це слабкий зв’язок, де об’єкти можуть існувати незалежно один від одного (наприклад, університет і студент).",
        "wrongAnswers": [
            "Математична операція підсумовування всіх полів об’єкта.",
            "Спосіб об'єднання Java-класів у один великий файл при компіляції."
        ]
    },
    {
        "id": 64, "topic": "Java OOP", "question": "Що таке композиція?", "answer": "Композиція – це сильний зв’язок, де життєвий цикл внутрішнього об’єкта залежить від зовнішнього (наприклад, кімната і будинок).",
        "wrongAnswers": [
            "Процес написання музики за допомогою спеціальних бібліотек Java.",
            "Тип даних, що дозволяє зберігати одночасно картинки, звуки та текст."
        ]
    },
    {
        "id": 65, "topic": "Java OOP", "question": "Що таке SOLID і які його основні принципи?", "answer": "SOLID – це п’ять принципів дизайну: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion.",
        "wrongAnswers": [
            "Це назва нового компілятора, який прийшов на заміну стандартному JDK.",
            "Це типи баз даних: Simple, Organized, Linear, Integrated, Durable."
        ]
    },
    {
        "id": 66, "topic": "Java OOP", "question": "Що таке DRY (Don't Repeat Yourself)?", "answer": "Це принцип, що закликає уникати дублювання інформації в коді.",
        "wrongAnswers": [
            "Порада не використовувати коментарі, якщо код і так зрозумілий.",
            "Заборона використання циклів for та while у Java-програмах."
        ]
    },
    {
        "id": 67, "topic": "Java Collections", "question": "Що таке Java Collections Framework?", "answer": "Це архітектура для зберігання та маніпулювання групою об’єктів, яка забезпечує спільні інтерфейси, такі як List, Set, Map.",
        "wrongAnswers": [
            "Це набір інструментів для збору статистики про продуктивність Java-додатка.",
            "Спеціальна бібліотека для створення ігор з великими ігровими світами."
        ]
    },
    {
        "id": 68, "topic": "Java Collections", "question": "Які основні інтерфейси існують у Collections Framework?", "answer": "Collection, List, Set, Queue, Deque, Map (хоча Map не розширює Collection безпосередньо).",
        "wrongAnswers": [
            "Input, Output, Connect, Filter, Transform.",
            "Text, Integer, Float, Boolean, Character."
        ]
    },
    {
        "id": 69, "topic": "Java Collections", "question": "Яка різниця між List, Set та Map?", "answer": "List – впорядкований список з дублікатами; Set – унікальні елементи без порядку; Map – сховище ключ-значення.",
        "wrongAnswers": [
            "List для чисел, Set для тексту, Map для дат та часу.",
            "Між ними немає жодної різниці, це різні назви одного класу."
        ]
    },
    {
        "id": 70, "topic": "Java Collections", "question": "Що таке ArrayList та LinkedList?", "answer": "ArrayList базується на динамічному масиві (швидкий доступ за індексом), а LinkedList – на зв’язаному списку (швидке вставлення/видалення).",
        "wrongAnswers": [
            "ArrayList для цілих чисел, LinkedList для дробових чисел.",
            "ArrayList працює лише в пам'яті, LinkedList зберігається на диску."
        ]
    },
    {
        "id": 71, "topic": "Java Collections", "question": "Яка різниця між HashSet, LinkedHashSet та TreeSet?", "answer": "HashSet не гарантує порядку; LinkedHashSet зберігає порядок вставки; TreeSet зберігає елементи в природному порядку (відсортовані).",
        "wrongAnswers": [
            "TreeSet використовується тільки для представлення генеалогічних дерев.",
            "HashSet завжди в 10 разів повільніше за LinkedHashSet."
        ]
    },
    {
        "id": 72, "topic": "Java Collections", "question": "Яка різниця між HashMap, LinkedHashMap та TreeMap?", "answer": "HashMap не гарантує порядку ключів; LinkedHashMap зберігає порядок вставки; TreeMap сортує за ключами.",
        "wrongAnswers": [
            "TreeMap дозволяє зберігати дубльовані ключі, а HashMap – ні.",
            "LinkedHashMap – це Map, яка автоматично підключається до бази даних."
        ]
    },
    {
        "id": 73, "topic": "Java Collections", "question": "Як працює HashMap всередині?", "answer": "HashMap використовує масив «бакетів» і хеш-функції для перетворення ключів у індекси масиву. Колізії вирішуються через зв’язані списки або дерева.",
        "wrongAnswers": [
            "HashMap просто зберігає всі дані в текстовому файлі та шукає їх рядком.",
            "Це проста структура, яка по черзі перебирає всі елементи для пошуку."
        ]
    },
    {
        "id": 74, "topic": "Java Collections", "question": "Що таке колізія в HashMap і як вона вирішується?", "answer": "Колізія – це ситуація, коли різні ключі мають однаковий хеш-код. Вирішується за допомогою ланцюжків (Chaining) або червоно-чорних дерев (у Java 8+).",
        "wrongAnswers": [
            "Колізія – це коли два ключі мають однакову назву; вони просто видаляються.",
            "Це помилка, яка призводить до миттєвої зупинки виконання програми."
        ]
    },
    {
        "id": 75, "topic": "Java Collections", "question": "Яка різниця між Iterator та Iterable?", "answer": "Iterable – інтерфейс класу, що дозволяє отримати ітератор; Iterator – сам об’єкт, що перебирає колекцію за допомогою next(), hasNext().",
        "wrongAnswers": [
            "Iterator – це застаріла версія Iterable, що не використовується з Java 5.",
            "Iterable використовується для циклів while, а Iterator – для switch-case."
        ]
    },
    {
        "id": 76, "topic": "Java Collections", "question": "Як реалізовано методи equals() та hashCode() і чому вони важливі?", "answer": "Вони використовуються для порівняння об’єктів та коректної роботи в хеш-колекціях. Якщо equals() повертає true, hashCode() має бути однаковим.",
        "wrongAnswers": [
            "equals() порівнює розмір об’єкта в байтах, а hashCode() – його назву.",
            "Ці методи автоматично генерують паролі для безпечного доступу до об’єкта."
        ]
    },
    {
        "id": 77, "topic": "Java Collections", "question": "Що таке fail-fast та fail-safe ітератори?", "answer": "Fail-fast ітератори кидають ConcurrentModificationException, якщо колекція змінюється під час ітерації; fail-safe ітератори працюють con копією.",
        "wrongAnswers": [
            "Fail-fast працюють швидше, але частіше ламають комп'ютер розробника.",
            "Це режими роботи Garbage Collector'а при великому навантаженні на ОЗУ."
        ]
    },
    {
        "id": 78, "topic": "Java Collections", "question": "Які особливості використання PriorityQueue?", "answer": "PriorityQueue впорядковує елементи за їх природним порядком або відповідно до Comparator, забезпечуючи доступ до найменшого/найбільшого елемента.",
        "wrongAnswers": [
            "Це черга, яка працює лише з потоками (Threads) високого пріоритету.",
            "Вона автоматично відправляє всі повідомлення в початок списку."
        ]
    },
    {
        "id": 79, "topic": "Java Collections", "question": "Що таке BlockingQueue?", "answer": "Це черга, що підтримує операції, які чекають на наявність елемента або вільного місця, широко використовується в багатопоточності.",
        "wrongAnswers": [
            "Це черга, яка повністю блокує доступ до інтернету під час своєї роботи.",
            "Це помилка в коді, яка призводить до «зависання» всього інтерфейсу."
        ]
    },
    {
        "id": 80, "topic": "Java Collections", "question": "Як працює ConcurrentHashMap?", "answer": "ConcurrentHashMap дозволяє потік-безпечний доступ до даних, використовуючи сегментацію або по-елементне блокування для підвищення продуктивності.",
        "wrongAnswers": [
            "Вона просто робить усі методи синхронізованими (synchronized), як у Vector.",
            "Вона зберігає дані на декількох серверах одночасно для безпеки."
        ]
    },
    {
        "id": 81, "topic": "Java Collections", "question": "Яка різниця між Array і ArrayList?", "answer": "Масив має фіксований розмір і може містити примітиви; ArrayList має динамічний розмір і працює лише з об’єктами.",
        "wrongAnswers": [
            "Масив працює повільніше, ніж ArrayList, у 100 разів.",
            "Array – це частина Java, а ArrayList – це зовнішня бібліотека від Google."
        ]
    },
    {
        "id": 82, "topic": "Java Collections", "question": "Що таке Comparable та Comparator?", "answer": "Comparable використовується для визначення природного порядку об’єкта (compareTo()); Comparator – для налаштування зовнішньої логіки порівняння (compare()).",
        "wrongAnswers": [
            "Comparable використовується для чисел, а Comparator – для текстових рядків.",
            "Це інтерфейси для перевірки, чи є комп’ютер сумісним з кодом Java."
        ]
    },
    {
        "id": 83, "topic": "Functional Interfaces", "question": "Що таке лямбда-вирази в Java?", "answer": "Лямбда-вирази – це короткий синтаксис для реалізації функціональних інтерфейсів (анонімні функції).",
        "wrongAnswers": [
            "Це математичні формули, що вбудовані в мову для наукових розрахунків.",
            "Це спосіб створення циклів без використання ключових слів for та while."
        ]
    },
    {
        "id": 84, "topic": "Functional Interfaces", "question": "Що таке функціональні інтерфейси?", "answer": "Функціональні інтерфейси – це інтерфейси, що мають рівно один абстрактний метод, помічені анотацією @FunctionalInterface (необов’язково).",
        "wrongAnswers": [
            "Інтерфейси, які мають лише статичні методи та константи для налаштування.",
            "Інтерфейси, що містять більше 10 різних методів для багатофункціональності."
        ]
    },
    {
        "id": 85, "topic": "Functional Interfaces", "question": "Які вбудовані функціональні інтерфейси ви знаєте?", "answer": "Predicate, Function, Supplier, Consumer, UnaryOperator, BinaryOperator.",
        "wrongAnswers": [
            "InputBuffer, OutputBuffer, DataChannel, StreamHandler.",
            "TrueFalse, DoTask, GiveData, TakeData."
        ]
    },
    {
        "id": 86, "topic": "Functional Interfaces", "question": "Що таке Predicate?", "answer": "Predicate<T> – приймає аргумент і повертає boolean (використовується для фільтрації).",
        "wrongAnswers": [
            "Це метод для прогнозування поведінки користувача на сайті.",
            "Клас, що автоматично додає «не» перед кожним значенням String."
        ]
    },
    {
        "id": 87, "topic": "Functional Interfaces", "question": "Що таке Function?", "answer": "Function<T, R> – приймає один тип і повертає інший (для перетворення).",
        "wrongAnswers": [
            "Це синонім до будь-якого методу, написаного на мові Java.",
            "Об’єкт, що зберігає виключно формули для розрахунку ПДВ."
        ]
    },
    {
        "id": 88, "topic": "Functional Interfaces", "question": "Що таке Consumer?", "answer": "Consumer<T> – приймає аргумент, виконує дію і нічого не повертає.",
        "wrongAnswers": [
            "Користувач, який підключився до вашого сервера через HTTP.",
            "Клас для видалення всіх об’єктів з оперативної пам’яті."
        ]
    },
    {
        "id": 89, "topic": "Functional Interfaces", "question": "Що таке Supplier?", "answer": "Supplier<T> – не приймає аргументів і повертає об’єкт.",
        "wrongAnswers": [
            "Компанія-постачальник ліцензійного програмного забезпечення.",
            "Інструмент для автоматичного завантаження JAR-файлів з Maven Central."
        ]
    },
    {
        "id": 90, "topic": "Functional Interfaces", "question": "Що таке UnaryOperator та BinaryOperator?", "answer": "UnaryOperator<T> – приймає і повертає один тип даних; BinaryOperator<T> – працює con двома аргументами одного типу.",
        "wrongAnswers": [
            "Це спеціалісти, які обслуговують бази даних у великих центрах даних.",
            "Оператори, що працюють тільки з одиницями та нулями в бінарному коді."
        ]
    },
    {
        "id": 91, "topic": "Functional Interfaces", "question": "Як використовувати посилання на методи (method references)?", "answer": "Посилання на методи (::) – це ще коротша форма лямбда-виразів для виклику існуючих методів (наприклад, System.out::println).",
        "wrongAnswers": [
            "Це спосіб копіювання посилання на об’єкт у іншу змінну.",
            "Це URL-адреса, що вказує на документацію до конкретного методу в мережі."
        ]
    },
    {
        "id": 92, "topic": "Streams", "question": "Що таке Stream API у Java?", "answer": "Stream API – це потужний інструмент для обробки колекцій даних у функціональному стилі, що дозволяє виконувати фільтрацію, перетворення та агрегацію.",
        "wrongAnswers": [
            "Бібліотека для прямої трансляції відео з веб-камери розробника.",
            "Протокол для передачі великих файлів по локальній мережі."
        ]
    },
    {
        "id": 93, "topic": "Streams", "question": "Як створити об’єкт Stream?", "answer": "Stream можна створити з колекції (list.stream()), масиву (Arrays.stream()), або значень (Stream.of()).",
        "wrongAnswers": [
            "Шляхом виклику конструктора new Stream(data).",
            "За допомогою команди Stream.create() у IntelliJ IDEA."
        ]
    },
    {
        "id": 94, "topic": "Streams", "question": "Яка різниця між intermediate та terminal операціями?", "answer": "Intermediate операції повертають новий Stream і є лінивими; Terminal операції запускають обробку та повертають кінцевий результат (або void).",
        "wrongAnswers": [
            "Intermediate працюють тільки з числами, а terminal тільки з текстом.",
            "Intermediate виконуються на сервері, а terminal – у браузері користувача."
        ]
    },
    {
        "id": 95, "topic": "Streams", "question": "Наведіть приклади intermediate операцій.", "answer": "Filter(), map(), sorted(), distinct(), limit(), skip().",
        "wrongAnswers": [
            "ForEach(), collect(), sum(), count().",
            "Print(), log(), save(), exit()."
        ]
    },
    {
        "id": 96, "topic": "Streams", "question": "Наведіть приклади terminal операцій.", "answer": "ForEach(), collect(), reduce(), count(), min(), max(), findFirst(), anyMatch().",
        "wrongAnswers": [
            "Map(), filter(), sorted(), distinct().",
            "Start(), run(), delete(), update()."
        ]
    },
    {
        "id": 97, "topic": "Streams", "question": "Як працює фільтрація в Streams?", "answer": "Операція filter() приймає Predicate і створює новий потік, що містить лише елементи, які відповідають умові.",
        "wrongAnswers": [
            "Вона видаляє всі елементи, що містять слово «error» у назві.",
            "Фільтр автоматично сортує елементи за довжиною вмісту."
        ]
    },
    {
        "id": 98, "topic": "Streams", "question": "Що таке перетворення типів дані в Stream (map)?", "answer": "Операція map() застосовує функцію до кожного елемента потоку, перетворюючи його на нове значення або інший тип.",
        "wrongAnswers": [
            "Це створення географічної карти проєкту для кращої навігації.",
            "Це перетворення всього проекту Java у формат Google Maps API."
        ]
    },
    {
        "id": 99, "topic": "Streams", "question": "Як працює операція reduce()?", "answer": "Reduce() агрегує елементи потоку в одне значення, послідовно застосовуючи бінарну операцію (наприклад, сума чисел).",
        "wrongAnswers": [
            "Вона видаляє всі дублікати та порожні рядки з потоку.",
            "Вона автоматично робить потік у 2 рази меншим для економії пам'яті."
        ]
    },
    {
        "id": 100, "topic": "Streams", "question": "Як використовувати паралельні потоки (parallel streams)?", "answer": "Паралельні потоки (parallelStream()) дозволяють виконувати операції одночасно на кількох ядрах процесора, що може прискорити обробку великих даних.",
        "wrongAnswers": [
            "Вони автоматично дублюють код на два різних комп’ютери.",
            "Паралельні потоки використовуються лише для малювання 3D-графіки."
        ]
    }
]);
